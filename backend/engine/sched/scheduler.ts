// sched/scheduler.ts
// Lightweight scheduler with interval/once/cron, retries with backoff, and job controls.
// ESM/NodeNext friendly. No external deps.

type TaskFn<T = any> = () => Promise<T> | T;

export type BackoffKind = "constant" | "linear" | "exponential" | "decorrelated-jitter";
export type RetryOptions = {
  retries?: number;           // default 0 (no retries)
  timeoutMs?: number;         // per-attempt timeout
  kind?: BackoffKind;         // default "exponential"
  baseMs?: number;            // default 250
  maxMs?: number;             // default 30_000
  factor?: number;            // default 2
  jitter?: boolean;           // default true
};

export type ScheduleKind = "once" | "interval" | "cron";

export type JobSpec = {
  id?: string;                        // autogenerated if missing
  name?: string;
  kind: ScheduleKind;

  // once
  at?: Date | number;                 // when kind === "once" (epoch ms or Date)

  // interval
  everyMs?: number;                   // when kind === "interval"
  jitterPct?: number;                 // 0..1 (applied to interval)

  // cron
  cron?: string;                      // standard 5-field: m h dom mon dow

  // execution
  task: TaskFn<void>;
  retries?: RetryOptions;             // per-job retry policy
  skipIfRunning?: boolean;            // default true (no overlapping)
  tags?: string[];
  meta?: Record<string, any>;
};

export type JobState = {
  id: string;
  name?: string;
  kind: ScheduleKind;
  status: "scheduled" | "running" | "paused" | "cancelled";
  runs: number;
  failures: number;
  lastRunAt?: number;
  lastError?: string;
  nextRunAt?: number | null;
  createdAt: number;
  updatedAt: number;
};

export type JobHandle = {
  id: string;
  info: () => JobState & { spec: Omit<JobSpec,"task"> };
  pause: () => void;
  resume: () => void;
  cancel: () => void;
  runNow: () => Promise<void>;
};

/* ============================================================
   Small utils
   ============================================================ */

const clamp = (x: number, lo: number, hi: number) => Math.max(lo, Math.min(hi, x));
const now = () => Date.now();
let _idSeq = 0;
function nextId() { return `job-${Date.now()}-${_idSeq++}`; }

function withTimeout<T>(p: Promise<T>, ms?: number): Promise<T> {
  if (!ms || ms <= 0) return p;
  let t: NodeJS.Timeout;
  return new Promise<T>((resolve, reject) => {
    t = setTimeout(() => reject(new Error(`task timed out after ${ms}ms`)), ms);
    p.then(v => { clearTimeout(t); resolve(v); }, e => { clearTimeout(t); reject(e); });
  });
}

function nextDelay(attempt: number, opts: Required<Omit<RetryOptions,"retries"|"timeoutMs">>): number {
  const { kind, baseMs, maxMs, factor, jitter } = opts;
  let d: number;
  switch (kind) {
    case "constant":     d = baseMs; break;
    case "linear":       d = baseMs + attempt * baseMs * (factor - 1); break;
    case "decorrelated-jitter": {
      const hi = Math.min(maxMs, baseMs * Math.pow(factor, attempt + 1));
      const lo = baseMs;
      d = lo + Math.random() * (hi - lo);
      break;
    }
    case "exponential":
    default:             d = baseMs * Math.pow(factor, attempt);
  }
  d = Math.min(d, maxMs);
  if (jitter) {
    const sign = Math.random() < 0.5 ? -1 : 1;
    d = clamp(d + sign * d * 0.1 * Math.random(), 0, maxMs); // Â±10% jitter
  }
  return Math.round(d);
}

/* ============================================================
   Cron parser (supports *, ranges, lists, steps)
   ============================================================ */

type Cron = { mins: Set<number>; hrs: Set<number>; dom: Set<number>; mon: Set<number>; dow: Set<number> };

function parseCron(expr: string): Cron {
  const parts = expr.trim().split(/\s+/);
  if (parts.length !== 5) throw new Error(`cron must have 5 fields: "${expr}"`);
  const [m, h, D, M, W] = parts;
  return {
    mins: parseField(m, 0, 59),
    hrs:  parseField(h, 0, 23),
    dom:  parseField(D, 1, 31),
    mon:  parseField(M, 1, 12),
    dow:  parseField(W, 0, 6),
  };
}

function parseField(field: string, lo: number, hi: number): Set<number> {
  const out = new Set<number>();
  const add = (v: number) => { if (v >= lo && v <= hi) out.add(v); };

  const chunks = field.split(",");
  for (const ch of chunks) {
    const stepMatch = ch.split("/");
    const main = stepMatch[0];
    const step = stepMatch[1] ? Math.max(1, parseInt(stepMatch[1], 10)) : 1;

    if (main === "*") {
      for (let v = lo; v <= hi; v += step) add(v);
      continue;
    }

    const range = main.split("-");
    if (range.length === 2) {
      const a = parseInt(range[0], 10); const b = parseInt(range[1], 10);
      const rlo = Math.min(a, b), rhi = Math.max(a, b);
      for (let v = rlo; v <= rhi; v += step) add(v);
      continue;
    }

    const val = parseInt(main, 10);
    if (!Number.isFinite(val)) throw new Error(`invalid cron field: "${field}"`);
    if ((val - lo) % step === 0) add(val);
  }
  return out;
}

/** Compute next fire time strictly after `fromMs` (search up to ~366 days). */
function nextCronTime(cron: Cron, fromMs: number): number | null {
  const d = new Date(fromMs + 60 * 1000); // start at next minute
  d.setSeconds(0, 0);

  // Search minute by minute up to one year ahead
  for (let i = 0; i < 60 * 24 * 366; i++) {
    const m = d.getMinutes();
    const h = d.getHours();
    const M = d.getMonth() + 1;
    const D = d.getDate();
    const W = d.getDay(); // 0..6

    if (cron.mins.has(m) && cron.hrs.has(h) && cron.mon.has(M) && cron.dom.has(D) && cron.dow.has(W)) {
      return d.getTime();
    }
    d.setMinutes(d.getMinutes() + 1);
  }
  return null;
}

/* ============================================================
   Tiny events
   ============================================================ */

type Listener<T> = (payload: T) => void;
class Evt {
  private map = new Map<string, Set<Listener<any>>>();
  on<T>(ev: string, fn: Listener<T>) { if (!this.map.has(ev)) this.map.set(ev, new Set()); this.map.get(ev)!.add(fn as any); }
  off<T>(ev: string, fn: Listener<T>) { this.map.get(ev)?.delete(fn as any); }
  emit<T>(ev: string, payload: T) { this.map.get(ev)?.forEach(fn => fn(payload)); }
}

/* ============================================================
   Scheduler
   ============================================================ */

type InternalJob = {
  spec: JobSpec;
  state: JobState;
  timer?: NodeJS.Timeout | null;
  cron?: Cron;
  running: boolean;
};

export class Scheduler {
  private jobs = new Map<string, InternalJob>();
  private ev = new Evt();
  private maxConcurrent: number;
  private runningCount = 0;

  constructor(opts?: { maxConcurrent?: number }) {
    this.maxConcurrent = Math.max(1, opts?.maxConcurrent ?? 32);
  }

  /* ----- events ----- */
  on(ev: "job:add" | "job:update" | "job:remove" | "run:start" | "run:success" | "run:error", fn: Listener<any>) {
    this.ev.on(ev, fn);
  }
  off(ev: string, fn: Listener<any>) { this.ev.off(ev, fn); }

  /* ----- public API ----- */

  add(spec: JobSpec): JobHandle {
    if (typeof spec.task !== "function") throw new Error("spec.task must be a function");
    const id = spec.id ?? nextId();
    if (this.jobs.has(id)) throw new Error(`job already exists: ${id}`);

    const st: JobState = {
      id,
      name: spec.name,
      kind: spec.kind,
      status: "scheduled",
      runs: 0,
      failures: 0,
      createdAt: now(),
      updatedAt: now(),
      nextRunAt: undefined,
    };

    const job: InternalJob = { spec: { skipIfRunning: true, ...spec, id }, state: st, running: false, timer: null };
    if (job.spec.kind === "cron") job.cron = parseCron(job.spec.cron || "* * * * *");

    this.jobs.set(id, job);
    this.plan(job, /*runNow*/ false);
    this.ev.emit("job:add", { id, spec: { ...spec, id }, state: { ...st } });

    return this.makeHandle(job);
  }

  list(): Array<JobState & { spec: Omit<JobSpec, "task"> }> {
    return Array.from(this.jobs.values()).map(j => ({ ...j.state, spec: this.stripTask(j.spec) }));
  }

  get(id: string): (JobState & { spec: Omit<JobSpec, "task"> }) | undefined {
    const j = this.jobs.get(id);
    return j ? { ...j.state, spec: this.stripTask(j.spec) } : undefined;
  }

  pause(id: string) {
    const j = this.must(id);
    if (j.state.status === "cancelled") return;
    j.state.status = "paused";
    j.state.updatedAt = now();
    if (j.timer) clearTimeout(j.timer);
    j.timer = null;
    j.state.nextRunAt = null;
    this.ev.emit("job:update", { id, state: { ...j.state } });
  }

  resume(id: string) {
    const j = this.must(id);
    if (j.state.status !== "paused") return;
    j.state.status = "scheduled";
    j.state.updatedAt = now();
    this.plan(j, /*runNow*/ false);
    this.ev.emit("job:update", { id, state: { ...j.state } });
  }

  cancel(id: string) {
    const j = this.must(id);
    j.state.status = "cancelled";
    j.state.updatedAt = now();
    if (j.timer) clearTimeout(j.timer);
    j.timer = null;
    j.state.nextRunAt = null;
    this.jobs.delete(id);
    this.ev.emit("job:remove", { id });
  }

  async runNow(id: string): Promise<void> {
    const j = this.must(id);
    await this.execute(j, /*manual*/ true);
  }

  /* ----- internals ----- */

  private stripTask(spec: JobSpec): Omit<JobSpec, "task"> {
    const { task, ...rest } = spec;
    return rest;
  }

  private must(id: string): InternalJob {
    const j = this.jobs.get(id);
    if (!j) throw new Error(`unknown job: ${id}`);
    return j;
  }

  private plan(j: InternalJob, runNowFlag: boolean) {
    if (j.state.status !== "scheduled") return;

    const scheduleKind = j.spec.kind;
    let delay = 0;
    let nextAt: number | null = null;

    if (runNowFlag) {
      delay = 0;
      nextAt = now();
    } else if (scheduleKind === "once") {
      const at = (j.spec.at instanceof Date) ? j.spec.at.getTime() : Number(j.spec.at ?? 0);
      if (!Number.isFinite(at)) throw new Error("once.at must be a Date or epoch ms");
      const t = Math.max(now(), at);
      delay = Math.max(0, t - now());
      nextAt = t;
    } else if (scheduleKind === "interval") {
      const base = Math.max(1, j.spec.everyMs ?? 1000);
      const jpct = clamp(j.spec.jitterPct ?? 0, 0, 1);
      const sign = Math.random() < 0.5 ? -1 : 1;
      delay = Math.round(base + sign * base * jpct * Math.random());
      delay = Math.max(0, delay);
      nextAt = now() + delay;
    } else if (scheduleKind === "cron") {
      const t = nextCronTime(j.cron!, now());
      if (t == null) { j.state.nextRunAt = null; return; }
      delay = Math.max(0, t - now());
      nextAt = t;
    }

    // Set timer
    if (j.timer) clearTimeout(j.timer);
    j.state.nextRunAt = nextAt ?? null;
    j.timer = setTimeout(() => this.execute(j, /*manual*/ false), delay);
  }

  private async execute(j: InternalJob, manual: boolean) {
    if (j.state.status !== "scheduled") return;
    if (j.running && (j.spec.skipIfRunning ?? true)) {
      // skip overlap; re-plan next occurrence
      this.plan(j, /*runNow*/ false);
      return;
    }
    if (this.runningCount >= this.maxConcurrent) {
      // requeue soon to respect global concurrency
      j.timer = setTimeout(() => this.execute(j, manual), 50);
      return;
    }

    j.running = true;
    this.runningCount++;
    j.state.lastRunAt = now();
    j.state.updatedAt = now();
    this.ev.emit("run:start", { id: j.state.id, manual });

    const r = j.spec.retries ?? {};
    const cfg: Required<Omit<RetryOptions,"retries"|"timeoutMs">> = {
      kind: r.kind ?? "exponential",
      baseMs: r.baseMs ?? 250,
      maxMs: r.maxMs ?? 30_000,
      factor: r.factor ?? 2,
      jitter: r.jitter !== false,
    };
    const maxAttempts = Math.max(0, r.retries ?? 0) + 1;
    const timeoutMs = r.timeoutMs;

    let attempt = 0;
    let error: any = null;

    while (attempt < maxAttempts) {
      try {
        await withTimeout(Promise.resolve(j.spec.task()), timeoutMs);
        error = null;
        break;
      } catch (e) {
        error = e;
        attempt++;
        if (attempt >= maxAttempts) break;
        const delay = nextDelay(attempt - 1, cfg);
        await new Promise(res => setTimeout(res, delay));
      }
    }

    if (error) {
      j.state.failures += 1;
      j.state.lastError = (error as any)?.message ?? String(error);
      this.ev.emit("run:error", { id: j.state.id, error: j.state.lastError });
    } else {
      j.state.runs += 1;
      j.state.lastError = undefined;
      this.ev.emit("run:success", { id: j.state.id });
    }

    // For "once" jobs, cancel after first execution
    if (j.spec.kind === "once") {
      this.cancel(j.state.id);
    } else {
      // replan the next
      j.running = false;
      this.runningCount = Math.max(0, this.runningCount - 1);
      this.plan(j, /*runNow*/ false);
      this.ev.emit("job:update", { id: j.state.id, state: { ...j.state } });
    }
  }

  /* ----- helpers to create jobs quickly ----- */

  every(everyMs: number, task: TaskFn<void>, opts?: Omit<JobSpec, "kind" | "everyMs" | "task">): JobHandle {
    return this.add({ kind: "interval", everyMs, task, ...opts });
  }

  at(at: Date | number, task: TaskFn<void>, opts?: Omit<JobSpec, "kind" | "at" | "task">): JobHandle {
    return this.add({ kind: "once", at, task, ...opts });
  }

  cron(expr: string, task: TaskFn<void>, opts?: Omit<JobSpec, "kind" | "cron" | "task">): JobHandle {
    return this.add({ kind: "cron", cron: expr, task, ...opts });
  }

  /* ----- handle builder ----- */

  private makeHandle(j: InternalJob): JobHandle {
    return {
      id: j.state.id,
      info: () => ({ ...j.state, spec: this.stripTask(j.spec) }),
      pause: () => this.pause(j.state.id),
      resume: () => this.resume(j.state.id),
      cancel: () => this.cancel(j.state.id),
      runNow: () => this.runNow(j.state.id),
    };
  }
}

/* ============================================================
   Default singleton (optional)
   ============================================================ */

export const scheduler = new Scheduler();

export default scheduler;

/* ============================================================
   Demo when run directly (optional)
   ============================================================ */

if (import.meta.url === `file://${process.argv[1]}`) {
  const s = new Scheduler({ maxConcurrent: 4 });

  s.on("run:start",   (e) => console.log("[start]", e));
  s.on("run:success", (e) => console.log("[ok]   ", e));
  s.on("run:error",   (e) => console.log("[err]  ", e));
  s.on("job:add",     (e) => console.log("[add]  ", e.id));
  s.on("job:update",  (e) => console.log("[upd]  ", e.id));
  s.on("job:remove",  (e) => console.log("[rm]   ", e.id));

  // Interval job with jitter + retries
  s.every(1000, async () => {
    if (Math.random() < 0.3) throw new Error("flaky");
    // do work...
  }, { name: "interval-flaky", jitterPct: 0.2, retries: { retries: 2, baseMs: 200, kind: "exponential" } });

  // Cron: every minute at second 0 (standard 5-field minute/hour/dom/mon/dow)
  s.cron("*/2 * * * *", () => console.log("cron tick:", new Date().toISOString()), { name: "cron-every-2m" });

  // One-off in 3 seconds
  s.at(Date.now() + 3000, () => console.log("one-off fired"), { name: "once-demo" });

  // Run a task now
  const h = s.every(5000, () => console.log("manual tick"), { name: "manual-ctl" });
  setTimeout(() => h.runNow(), 1500);
  setTimeout(() => h.pause(), 7000);
  setTimeout(() => h.resume(), 12000);
  setTimeout(() => h.cancel(), 18000);

  // Keep process alive for demo
  setTimeout(() => {
    console.log("\nJobs:", s.list());
    process.exit(0);
  }, 22000);
}